<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSV Analyzer â€” Classic Output + Date Choice</title>

<style>
:root{
  --bg:#0b1220;
  --card:#0f1a2e;
  --line:#24324a;
  --text:#e5e7eb;
  --muted:#94a3b8;
  --primary:#6366f1;
  --accent:#22d3ee;
  --success:#22c55e;
  --error:#ef4444;
  --warn:#f59e0b;
}
*{box-sizing:border-box}
body{
  margin:0;
  background:radial-gradient(800px 400px at 15% 0%, rgba(99,102,241,.35), transparent 60%),
             radial-gradient(600px 350px at 85% 10%, rgba(34,211,238,.25), transparent 60%),
             var(--bg);
  font-family:system-ui,-apple-system,Segoe UI,Roboto;
  color:var(--text);
}
.container{max-width:1400px;margin:36px auto;padding:0 16px;}
h1{margin:0 0 6px;font-size:22px}
p{margin:0 0 16px;color:var(--muted);font-size:13px}

.card{
  background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));
  border:1px solid var(--line);
  border-radius:18px;
  padding:18px;
}
.grid{
  display:grid;
  grid-template-columns:1.25fr .75fr;
  gap:16px;
}
@media(max-width:1000px){ .grid{grid-template-columns:1fr} }

textarea{
  width:100%;
  min-height:260px;
  background:#020617;
  color:var(--text);
  border:1px solid var(--line);
  border-radius:14px;
  padding:14px;
  font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
  font-size:13px;
  line-height:1.35;
  outline:none;
}
textarea:focus{
  border-color:rgba(99,102,241,.9);
  box-shadow:0 0 0 3px rgba(99,102,241,.18);
}
.panel{
  background:#020617;
  border:1px solid var(--line);
  border-radius:14px;
  padding:14px;
}
.kv{
  display:flex;
  justify-content:space-between;
  padding:10px 12px;
  background:rgba(255,255,255,.03);
  border:1px solid rgba(148,163,184,.12);
  border-radius:12px;
  margin-bottom:10px;
  font-size:13px;
}
.kv span{color:var(--muted)}
.controls{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin-top:8px;
}
button{
  flex:1;
  min-width:140px;
  padding:11px 14px;
  border-radius:12px;
  border:none;
  font-weight:900;
  cursor:pointer;
  color:white;
  background:linear-gradient(135deg,var(--primary),var(--accent));
}
button.secondary{
  background:#020617;
  border:1px solid var(--line);
  color:var(--text);
}
button:hover{opacity:.96}
.hr{height:1px;background:rgba(148,163,184,.18);border:none;margin:12px 0}

.modeRow{
  display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:8px
}
.mode{
  display:flex;align-items:center;gap:8px;
  padding:8px 10px;border-radius:12px;border:1px solid var(--line);
  background:rgba(255,255,255,.02);cursor:pointer;font-weight:900;font-size:13px
}
.mode input{accent-color:var(--accent)}

.rangeRow{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px}
input{
  width:100%;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid var(--line);
  background:#020617;
  color:var(--text);
  font-weight:900;
  outline:none;
}
input:focus{
  border-color:rgba(99,102,241,.9);
  box-shadow:0 0 0 3px rgba(99,102,241,.18);
}

.badges{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
.badge{
  padding:7px 10px;border-radius:999px;border:1px solid var(--line);
  background:rgba(255,255,255,.03);font-weight:900;font-size:12px
}
.badge b{color:var(--accent)}
.miniList{
  margin-top:10px;
  background:#020617;
  border:1px solid var(--line);
  border-radius:12px;
  padding:10px;
  max-height:200px;
  overflow:auto;
  font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
  font-size:12px;
  white-space:pre;
}
.status{
  margin-top:10px;
  padding:10px 12px;
  border-radius:12px;
  border:1px dashed rgba(148,163,184,.25);
  color:var(--muted);
  font-size:13px;
}

.table-wrap{
  margin-top:16px;
  background:#020617;
  border:1px solid var(--line);
  border-radius:16px;
  overflow:auto;
  max-height:540px;
}
table{width:100%;border-collapse:collapse;font-size:13px;}
thead{
  background:#0f1a2e;
  position:sticky;
  top:0;
  z-index:2;
}
th,td{
  padding:11px 12px;
  border-bottom:1px solid #24324a;
  white-space:nowrap;
}
tbody tr:hover{background:rgba(99,102,241,.08)}
.empty{
  text-align:center;
  padding:22px;
  color:var(--muted);
}
small.hint{color:var(--muted);display:block;margin-top:6px;font-size:12px}
</style>
</head>

<body>
<div class="container">
  <h1>CSV Analyzer</h1>
  <p>Classic output: table + range check. Choose date (single / range) before checking IDs.</p>

  <div class="card">
    <div class="grid">

      <textarea id="csvInput" placeholder='Paste data here...
Examples:
"2504, search Nathan passed successfully,2026-01-16"
"2502;Success;someone;email;2025-12-19 19:03"
13:47:53 (ignored)'></textarea>

      <div class="panel">
        <div class="kv"><span>Total rows parsed</span><b id="total">â€”</b></div>
        <div class="kv"><span>Visible rows (date filter)</span><b id="count">â€”</b></div>

        <div class="controls">
          <button id="btnProcess">Process</button>
          <button class="secondary" id="btnCopy">ðŸ“‹ Copy IDs</button>
          <button class="secondary" id="btnExport">â¬‡ Export CSV</button>
        </div>

        <hr class="hr">

        <div class="kv"><span>Date mode</span><b id="dateModeLabel">Single day</b></div>

        <div class="modeRow">
          <label class="mode"><input type="radio" name="dateMode" value="single" checked> Single day</label>
          <label class="mode"><input type="radio" name="dateMode" value="range"> Date range</label>
        </div>

        <div id="singleWrap" style="margin-top:10px">
          <input id="singleDate" placeholder="Day (YYYY-MM-DD or DD-MM-YYYY)">
          <small class="hint">Example: 2026-01-16 or 16-01-2026</small>
        </div>

        <div id="rangeWrap" style="margin-top:10px;display:none">
          <div class="rangeRow">
            <input id="dateFrom" placeholder="From day">
            <input id="dateTo" placeholder="To day">
          </div>
          <small class="hint">Auto-swap if From > To</small>
        </div>

        <div class="controls" style="margin-top:10px">
          <button class="secondary" id="btnApplyDate">Apply date</button>
          <button class="secondary" id="btnClearDate">Clear date</button>
        </div>

        <hr class="hr">

        <div class="kv"><span>ID Range (compare on visible rows)</span><b id="scopeLabel">â€”</b></div>

        <div class="rangeRow">
          <input id="fromId" type="number" value="1961" min="0" placeholder="From ID">
          <input id="toId" type="number" value="2240" min="0" placeholder="To ID">
        </div>

        <div class="controls">
          <button class="secondary" id="btnRange">Check Range</button>
          <button class="secondary" id="btnCopyMissing">Copy not processed</button>
          <button class="secondary" id="btnExportMissing">Export not processed</button>
        </div>

        <div class="badges">
          <div class="badge">Processed unique: <b id="procInRange">0</b></div>
          <div class="badge">Not processed: <b id="missingCount">0</b></div>
          <div class="badge">Duplicates: <b id="dupCount">0</b></div>
        </div>

        <div class="miniList" id="missingBox">Run "Check Range"â€¦</div>
        <div class="status" id="status">Waitingâ€¦</div>
      </div>

    </div>

    <div class="table-wrap">
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>STATUS</th>
            <th>DATETIME</th>
            <th>DAY</th>
          </tr>
        </thead>
        <tbody id="outputBody">
          <tr><td colspan="4" class="empty">No data yet</td></tr>
        </tbody>
      </table>
    </div>

  </div>
</div>

<script>
/* ===== Robust parsing (quotes + ; or , + last column date) ===== */
const $ = id => document.getElementById(id);

function setStatus(msg, type="muted"){
  const el = $("status");
  el.textContent = msg;
  el.style.color =
    type === "success" ? "var(--success)" :
    type === "error" ? "var(--error)" :
    type === "warn" ? "var(--warn)" : "var(--muted)";
}

function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function safeCsv(s){
  s = String(s ?? "");
  if(/[;\n\r"]/.test(s)) return '"' + s.replaceAll('"','""') + '"';
  return s;
}

function downloadBlob(content, filename, mime){
  const blob = new Blob([content], {type:mime});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function isTimeOnlyLine(line){
  const s = line.trim().replace(/^"+|"+$/g,"").replace(/^'+|'+$/g,"").trim();
  return /^\d{1,2}:\d{2}:\d{2}$/.test(s);
}

function detectDelimiter(lines){
  let semi = 0, comma = 0;
  for(const ln0 of lines){
    const ln = ln0.trim();
    if(!ln) continue;
    semi += (ln.match(/;/g) || []).length;
    comma += (ln.match(/,/g) || []).length;
    if(semi + comma > 12) break;
  }
  return comma > semi ? "," : ";";
}

function smartParseDay(dtRaw){
  if(!dtRaw || typeof dtRaw !== "string") return null;
  let s = dtRaw.trim()
    .replace(/^"+|"+$/g, "")
    .replace(/^'+|'+$/g, "")
    .trim();

  // date token before space/_ if exists
  let datePart = s;
  if(s.includes("_")) datePart = s.split("_")[0] || "";
  else if(/\s/.test(s)) datePart = s.split(/\s+/)[0] || "";

  datePart = datePart.replace(/\//g, "-").trim();
  const d = datePart.split("-");
  if(d.length !== 3) return null;

  let dd, mm, yyyy;
  if(d[0].length === 4){
    yyyy = Number(d[0]); mm = Number(d[1]); dd = Number(d[2]);
  } else {
    dd = Number(d[0]); mm = Number(d[1]); yyyy = Number(d[2]);
  }

  if([dd, mm, yyyy].some(v => Number.isNaN(v))) return null;
  if(yyyy < 1900 || yyyy > 2100) return null;
  if(mm < 1 || mm > 12) return null;
  if(dd < 1 || dd > 31) return null;

  const pad = n => String(n).padStart(2,"0");
  return `${yyyy}-${pad(mm)}-${pad(dd)}`;
}
function toUTCDate(dayKey){
  const [y,m,d] = dayKey.split("-").map(Number);
  return new Date(Date.UTC(y, m-1, d));
}

function cleanField(v){
  return String(v ?? "")
    .trim()
    .replace(/^"+|"+$/g,"")
    .replace(/^'+|'+$/g,"")
    .trim();
}

function parseText(text){
  const rawLines = text.replace(/\r/g,"").split("\n").map(l=>l.trim()).filter(Boolean);
  if(rawLines.length === 0) return [];

  const delim = detectDelimiter(rawLines);
  const rows = [];

  for(let line of rawLines){
    if(isTimeOnlyLine(line)) continue;

    // strip wrapping quotes on the whole line
    line = line.trim();
    if((line.startsWith('"') && line.endsWith('"')) || (line.startsWith("'") && line.endsWith("'"))){
      line = line.slice(1,-1).trim();
    }
    if(!line.includes(delim)) continue;

    const parts = line.split(delim).map(cleanField);
    if(parts.length < 2) continue;

    const idNum = parseInt(parts[0], 10);
    if(!Number.isFinite(idNum)) continue;

    const dtRaw = parts[parts.length - 1];
    const day = smartParseDay(dtRaw);
    if(!day) continue;

    const status = parts.slice(1, -1).join(delim).trim() || (parts[1] || "");

    rows.push({
      id: idNum,
      idText: String(idNum),
      status,
      datetime: dtRaw,
      day
    });
  }

  return rows;
}

/* ===== App state ===== */
let allRows = [];
let visibleRows = [];
let missingIDs = [];

/* ===== Render table output (classic) ===== */
function renderTable(){
  const body = $("outputBody");
  body.innerHTML = "";

  if(!visibleRows.length){
    body.innerHTML = `<tr><td colspan="4" class="empty">No rows</td></tr>`;
    $("count").textContent = "0";
    $("scopeLabel").textContent = "â€”";
    return;
  }

  for(const r of visibleRows){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${escapeHtml(r.idText)}</td>
      <td>${escapeHtml(r.status)}</td>
      <td>${escapeHtml(r.datetime)}</td>
      <td>${escapeHtml(r.day)}</td>
    `;
    body.appendChild(tr);
  }

  $("count").textContent = String(visibleRows.length);
  $("scopeLabel").textContent = `${visibleRows.length} rows`;
}

function resetRangeBox(){
  $("procInRange").textContent = "0";
  $("missingCount").textContent = "0";
  $("dupCount").textContent = "0";
  $("missingBox").textContent = 'Run "Check Range"â€¦';
  missingIDs = [];
}

/* ===== Date filter (single or range) ===== */
function dateMode(){
  const r = document.querySelector('input[name="dateMode"]:checked');
  return r ? r.value : "single";
}
function normalizeDateInput(v){
  v = String(v||"").trim();
  if(!v) return null;
  return smartParseDay(v);
}

function applyDateFilter(){
  if(!allRows.length){
    setStatus("Process first", "error");
    return;
  }

  const mode = dateMode();
  if(mode === "single"){
    const day = normalizeDateInput($("singleDate").value);
    if(!day){
      setStatus("Invalid single date", "error");
      return;
    }
    visibleRows = allRows.filter(r => r.day === day);
    renderTable();
    resetRangeBox();
    setStatus(`Filtered by day: ${day}`, "success");
  } else {
    const from = normalizeDateInput($("dateFrom").value);
    const to = normalizeDateInput($("dateTo").value);
    if(!from || !to){
      setStatus("Invalid date range", "error");
      return;
    }
    const a = toUTCDate(from).getTime();
    const b = toUTCDate(to).getTime();
    const lo = Math.min(a,b), hi = Math.max(a,b);

    visibleRows = allRows.filter(r=>{
      const t = toUTCDate(r.day).getTime();
      return t >= lo && t <= hi;
    });

    renderTable();
    resetRangeBox();
    setStatus(`Filtered range: ${from} â†’ ${to}`, "success");
  }
}

function clearDateFilter(){
  visibleRows = [...allRows];
  renderTable();
  resetRangeBox();

  $("singleDate").value = "";
  $("dateFrom").value = "";
  $("dateTo").value = "";

  setStatus("Date filter cleared (showing all rows)", "success");
}

/* ===== ID range check (classic logic) ===== */
function normalizeNumRange(a,b){
  let from = Number(a), to = Number(b);
  if(Number.isNaN(from) || Number.isNaN(to)) return null;
  if(from > to){ const t = from; from = to; to = t; }
  return {from,to};
}

function checkRange(){
  if(!visibleRows.length){
    setStatus("No visible rows (apply date first)", "error");
    return;
  }

  const rr = normalizeNumRange($("fromId").value, $("toId").value);
  if(!rr){
    setStatus("Invalid ID range", "error");
    return;
  }
  const {from, to} = rr;

  const counts = new Map();
  for(const r of visibleRows){
    counts.set(r.id, (counts.get(r.id) || 0) + 1);
  }

  // duplicates (inside visible scope)
  let dupN = 0;
  for(const [,c] of counts){
    if(c > 1) dupN++;
  }
  $("dupCount").textContent = String(dupN);

  // processed unique in ID range
  let processedUniqueInRange = 0;
  for(const [id] of counts){
    if(id >= from && id <= to) processedUniqueInRange++;
  }
  $("procInRange").textContent = String(processedUniqueInRange);

  // missing = full range minus present
  missingIDs = [];
  for(let i=from; i<=to; i++){
    if(!counts.has(i)) missingIDs.push(i);
  }
  $("missingCount").textContent = String(missingIDs.length);

  $("missingBox").textContent =
`Scope = visible rows (your date filter)
ID Range: ${from} â†’ ${to}

NOT processed (${missingIDs.length}):
${missingIDs.slice(0, 400).join("\n") || "â€”"}

(Preview first 400)`;

  setStatus("Range computed âœ…", "success");
}

function copyIDs(){
  if(!visibleRows.length){
    setStatus("No visible rows to copy", "error");
    return;
  }
  const ids = visibleRows.map(r=>r.idText).join("\n");
  navigator.clipboard.writeText(ids)
    .then(()=>setStatus(`Copied ${visibleRows.length} IDs`, "success"))
    .catch(()=>setStatus("Clipboard blocked by browser", "error"));
}

function exportVisibleCSV(){
  if(!visibleRows.length){
    setStatus("No visible rows to export", "error");
    return;
  }
  let csv = "ID;STATUS;DATETIME;DAY\n";
  for(const r of visibleRows){
    csv += `${safeCsv(r.idText)};${safeCsv(r.status)};${safeCsv(r.datetime)};${safeCsv(r.day)}\n`;
  }
  downloadBlob(csv, "visible.csv", "text/csv;charset=utf-8;");
  setStatus(`Exported visible.csv (${visibleRows.length} rows)`, "success");
}

function copyMissing(){
  if(!missingIDs.length){
    setStatus("No not-processed IDs to copy", "warn");
    return;
  }
  navigator.clipboard.writeText(missingIDs.join("\n"))
    .then(()=>setStatus(`Copied ${missingIDs.length} not processed IDs`, "success"))
    .catch(()=>setStatus("Clipboard blocked by browser", "error"));
}

function exportMissing(){
  if(!missingIDs.length){
    setStatus("No not-processed IDs to export", "warn");
    return;
  }
  const rr = normalizeNumRange($("fromId").value, $("toId").value);
  const name = rr ? `not_processed_${rr.from}-${rr.to}.csv` : "not_processed.csv";
  downloadBlob("ID\n" + missingIDs.join("\n"), name, "text/csv;charset=utf-8;");
  setStatus(`Exported ${name}`, "success");
}

/* ===== Process ===== */
function processCSV(){
  const text = $("csvInput").value.trim();
  if(!text){
    setStatus("Input empty", "error");
    return;
  }

  allRows = parseText(text);
  $("total").textContent = String(allRows.length);

  visibleRows = [...allRows];
  renderTable();
  resetRangeBox();

  if(!allRows.length){
    setStatus("No valid rows parsed (check delimiter / last column date)", "error");
    return;
  }

  // helper default: set singleDate to latest day in data
  const days = [...new Set(allRows.map(r=>r.day))].sort((a,b)=>b.localeCompare(a));
  $("singleDate").value = days[0] || "";
  setStatus("Parsed âœ… Choose date and Apply, then Check Range.", "success");
}

/* ===== Wire ===== */
$("btnProcess").addEventListener("click", processCSV);
$("btnCopy").addEventListener("click", copyIDs);
$("btnExport").addEventListener("click", exportVisibleCSV);

$("btnApplyDate").addEventListener("click", applyDateFilter);
$("btnClearDate").addEventListener("click", clearDateFilter);

$("btnRange").addEventListener("click", checkRange);
$("btnCopyMissing").addEventListener("click", copyMissing);
$("btnExportMissing").addEventListener("click", exportMissing);

document.querySelectorAll('input[name="dateMode"]').forEach(r=>{
  r.addEventListener("change", ()=>{
    const m = dateMode();
    $("dateModeLabel").textContent = (m === "single") ? "Single day" : "Date range";
    $("singleWrap").style.display = (m === "single") ? "block" : "none";
    $("rangeWrap").style.display  = (m === "range")  ? "block" : "none";
    resetRangeBox();
    setStatus(`Date mode: ${m}`, "success");
  });
});
</script>
</body>
</html>
